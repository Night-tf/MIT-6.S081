## 1. Operating system interfaces

操作系统的工作：1）为程序提供资源和服务；2）管理并抽象底层硬件；3）多路复用硬件（实现并行and并发）；4）提供程序间的交互方式

![figure0-1](E:\My_Software_File\Typora files\Image\f0-1.png)

-   xv6 系统：它是一种提供Unix操作系统中的基本接口，同时模仿Unix的内部设计的小型操作系统
-   内核：一个向其他运行中程序提供服务的特殊程序
-   进程通过系统调用从用户态进入核心态，让内核执行服务，之后内核返回
-   系统调用也就是内核提供的操作系统接口

shell 是一个普通的程序，而不是内核的一部分



### 1.1 Process and memory

一个xv6进程由两部分：用户内存空间（指令、数据、栈）和仅对内核可见的进程状态组成。xv6提供分时特性：它在一组等待进程之间透明的切换可用CPU，被分配到CPU的进程就可以执行。当一个进程不在执行时，xv6储存这些进程相关的CPU寄存器直到它下次执行。内核将每个进程和一个pid (process identifier)关联起来



```fork()```

-   一个进程可以通过系统调用```fork```来创建一个子进程，子进程和父进程的内存内容完全一致。```fork```在父进程和子进程中都返回（一次调用，两次返回），在父进程中返回子进程的pid(>0)，而在子进程中返回0
-   ```fork```创建的子进程会接着```fork```代码所在的行继续往下运行
-   父进程和子进程虽然刚开始的内存内容是一致的，但是他们具有不同的内存空间和寄存器，修改一个进程的内存内容并不会影响另一个进程

```exit()```

-   系统调用```exit```会让调用的进程停止，并且释放内存和打开的文件等资源。

```wait(int * x)```

-   系统调用```wait```会等待该进程的一个子进程结束，并且返回结束子进程的pid，同时将子进程的结束状态储存在x中。
-   如果子进程没有结束，那么```wait```会一直等待，直到某一个子进程结束为止。如果调用进程没有子进程，那么它会立即返回-1

```exec()```

-   系统调用```exec```将从某个文件中读取内存镜像，并将其替换到调用的进程的内存空间。该文件需要符合ELF文件格式。
-   ```exec```执行成功后不返回原来的调用进程，而是从ELF头中声明的入口开始，执行从文件中加载的指令
-   ```exec```接受两个参数：可执行文件名和一个字符串参数数组
-   参数列表的第一个参数应该是可执行文件名，惯例是可执行文件的名字



xv6通常隐式地分配用户的内存空间。```fork```在子进程需要装入父进程的内存拷贝时分配空间，```exec```在需要装入可执行文件时分配空间。一个进程可以在需要额外内存时可以通过调用```sbrk(n)```来增加n字节的数据内存，```sbrk```返回新的内存的地址

所有xv6进程都以root用户执行



### 1.2 I/O and File descriptors

文件描述符是一个整数，它代表了一个进程可以读写的被内核管理的对象，文件描述符的接口是对文件、管道、设备等的抽象，这种抽象使得他们看上去就是字节流

每个进程都有自己的独立的文件描述符列表，其中0代表标准输入，1代表标准输出，2代表标准错误输出。shell保证任何时刻都有3个打开的文件描述符，他们是控制台的默认文件描述符



```read()```

-   ```read(fd, buf, n)```从fd中读取至多n个字节，将它们拷贝到buf中，然后返回读取的字节数
-   每一个指向文件的文件描述符都和一个偏移offset关联，```read```从当前偏移处读取数据，然后把偏移增加读取的字节数，之后的read操作将从新的起点开始读取
-   当没有数据可读时，```read```就会返回0，这表示文件结束了

```write()```

-   系统调用```write(fd, buf, n)```将```buf```中的n个字节写到```fd```中，并且返回实际的写出的字节数。如果返回值小于n，那么只可能是发生了错误
-   与```read```一样，```write```也从当前偏移处开始写，在写的过程中增加偏移

```close()```

-   系统调用```close```可以释放一个文件描述符，使得它未来可以被```open```，```pipe```，```dup```等调用重用。
-   一个新分配的文件描述符永远都是这个进程的最小的未被使用的文件描述符



I/O重定向

-   使用```fork```创建子进程，子进程会复制父进程的内存和文件描述符
-   ```exec```会替换调用进程的内存空间，但是会保留调用进程的文件描述符
-   所以shell可以这样实现重定向：```fork```一个进程，使用```close```关闭某个文件描述符，然后重新打开指定文件的文件描述符，最后执行新的程序
-   父进程和子进程的文件描述符列表是相互独立的，但是他们的同一个文件的offset是共享的

```c
// 一个简化版的 shell 执行 cat<input.txt 的代码
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```

子进程关闭文件描述符0之后，我们可以保证```open```会使用0作为新打开的文件```input.txt```的文件描述符。之后```cat```会在标准输入指向```input.txt```的情况下运行。而xv6的shell正是这样实现重定向的

这也就是为什么```fork```和```exec```是两种单独的系统调用了，```fork```使得我们可以在子进程执行指定程序之前读子进程进行修改



```dup()```

-   系统调用```dup```复制一个已有的文件描述符，返回一个指向该文件的新的文件描述符，新旧文件描述符共享同一个文件偏移

只有```fork```和```dup```产生的文件描述符会共享offset，其他的都不会



### 1.3 Pipes

管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道一段写的数据，可以从管道另一端读取。

```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
```

子进程将管道的读端口拷贝在文件描述符0上，这样```wc```从标准输入读取数据时，实际上是从管道中读取的

如果数据没有准备好，那么对管道的```read```操作会一直等待，直到

-   直到有数据来临
-   直到绑定在这个管道的写端口的文件描述符都关闭了，那么这时候```read```会返回0，就像文件读到了末尾一样
-   这也就是为什么子进程需要关闭管道的写端口，因为子进程拷贝了管道的读端口在0上了，如果不关闭写端口，那么```wc```会拷贝一个管道的写端口，而这个写端口在```wc```中无法关闭，也就导致```wc```中的读端口（绑定在0上）永远读不到```eof```，永远都会等待



### 1.4 File system

xv6文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用，xv6将目录实现为一种特殊的文件。目录是一棵树，它的根节点是一个特殊的目录```root```，不以```/```开头的路径，都是相对路径

```chdir()```

-   该系统调用更改调用进程的当前目录

```mkdir()```

-   该系统调用创建一个新的目录

```open()```

-   该系统调用加上```O_CREATE```标志表示打开一个新的文件

```mknod()```

-   该系统调用在文件中创建一个设备文件，它有两个参数 major device #和 minor device #来唯一确定一个内核设备。当一个进程之后打开这个问价的时候，内核会将```read```和```write```的系统调用重定向到该设备上

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONGLY);
close(fd);
mknod("/console", 1, 1);
```



```fstat()```

-   系统调用```fstat(int fd, struct stat *st)```获取文件描述符指向文件的信息，将信息储存在结构体st中

文件名和这个文件本身是有很大区别的。一个文件（称为```inode```）可能有很多名字，这些名字称为```links```。系统调用```link()```能够为一个文件```inode```创建一个新的名字```link```，这时文件```inode```的链接数```nlink```加1。一个文件的```inode```和磁盘空间仅当它的链接数为0时，才会被清空。

link()

-   系统调用link能够为一个文件创建一个新的名字

```c
open("a", O_CREATE|O_WRONGLY);
link("a", "b");
```

上面a和b都是同一个文件```inode```的不同名字```link```，对两者的```fstat```会返回相同的信息

```unlink()```

-   系统调用```ulink```从文件系统删除一个文件名



xv6关于文件系统的操作都被实现为用户程序，例如```mkdir```，```ln```，```rm```等。这种设计允许任何人都可以通过用户命令拓展shell。有一个例外，那就是```cd```，它必须改变shell自身的当前工作目录。如果```cd```作为一个普通命令执行，那么shell就会```fork```一个子进程，而子进程会运行```cd```，```cd```只会改变子进程的当前工作目录。父进程的工作目录保持不变。



### 1.6 Lab 1: Xv6 and Unix Utilities

#### 1. sleep

调用sleep()的系统调用即可

#### 2. pingpong

使用两个管道完成，在进入父/子进程的时候，直接释放不需要的管道的文件描述符，结束的时候要释放使用的管道的文件描述符

C语言中没有字符串这种数据类型，有的只是字符数组。字符串一定是字符数组，但是字符数组不一定是字符串。关键就在于字符串的结尾必须是'\0'。

C语言中单个字符' '其实代表的是一个整数，而" "则代表了一个常量字符串，这个双引号做了三件事情

-   申请空间（在常量区），存放字符串
-   在字符串的末尾加上'\0'
-   返回地址

因此下面代码是正确的

```c
// write(int fd, void *, size_t)，其中第二个变量要求一个指针
write(1, " ", 1);          // 双引号会返回一个指针
// write(1, ' ', 1);       // 这个代码是错误的，因为单个字符' '相当于int
```



常量指针与指针常量

-   常量指针是指：指向常量的指针，也就是相当于底层 const
-   指针常量是指：指针本身是常量，也就是相当于顶层 const

C语言中数组名是一个指针常量，因此它有如下特性

```c
char a[10];
char b[10] = "abc";      // 正确，这是字符数组的初始化，初始化成了一个字符串
// a = "abvd"            // 错误，a是一个指针常量，这里是对a进行了赋值修改，赋值了一个地址，不允许对一个常量进行修改

// 下面两种都是合理的，a虽然是一个常量，但是a指向的并不是一个常量，可以修改赋值
a[0] = 'a';
*a = 'a';
```



#### 3. primes

要使用多进程并行运行

我们采用递归的方式来解决：每次从当前pipe中读取一个数字，如果读不到了，那么说明结束了。如果该数字不能被整除，那么创建一个新的pipe并且fork一个新的子进程，将这个不能被整除的数字送进这个新的pipe并且让子进程去接收

一定要及时关闭不用的文件描述符，否则xv6系统没有那么多资源

对于父进程来说，如果他收不到左边的输入了，就需要把右边管道的写入端的文件描述符给释放，这样才能让它的子进程的```read```操作停止等待，此时```read```会返回零，那么该子进程就会结束，然后一级一级全部结束。否则子进程无法结束，父进程由于```wait```的存在，也会一直等待导致整个程序无法结束。

#### 4. find

递归的时候，如果读取到的文件是```"."```或者```".."```，那么需要选择跳过

C语言中的字符串处理必须使用相应的函数：

-   ```strcpy(char *a, char *b)```：将b字符串的内容复制到a字符串中，```'\0'```也会复制，但是一般要保证a的长度比b长
-   ```strlen(char *a)```：计算字符串a的长度，计算长度的时候不计算```'\0'```
-   ```memmove(void *a, void *b, size_t n)```：用b开头的n个字节数据覆盖a开头的内个字节数据，可以覆盖自己的

#### 5. xargs

新的命令就是```main()```函数接收到的字符串数组的第二个字符串，直接将其作为```exec```的第一个参数即可

如果管道前面的标准输出有多行，那么该命令就需要执行多次

fork一个子进程，让子进程使用```exec```来执行```xargs```后面的命令

定义了一个指针变量，那么这个指针变量只能用来保存地址，如果这个地址所指向的空间不是系统分配给它的，那么对这块内存空间的赋值是非法的

```c
char *a;
char *b = "asg";         // 双引号给b指针分配了内存空间
// strcpy(a, b)          // 这一行是非法的，因为a指向的内存空间并不是系统分配的，这时候对这片内存空间的操作是非法的
```

数组名是一个常量指针，他表示的是数组中第一个元素的地址

数组指针表示指向数组的指针```int (*p)[5]```，p指向了一个包含5个int类型的数组

**指向数组的地址和指向数组首元素的地址是两件事**

```c
#include <stdio.h>

int main(){
    int temp[5] = {1,2,3,4,5};
    int (*p)[5] = &temp;
    // int (*p)[5] = temp;              // 这样是错误的，编译器可能会不通过
    
    int i;
    for(i=0; i<5; ++i){
        printf("%d\n", *(*p+i));
        // printf("%d\n", (*p)[i]);     // 这样也是可以的
    }
    return 0;
}

```

上述代码中，如果定义```int *p1 = a```，那么p1单纯的指向了一个变量，它指向的是a数组的首元素，而不是整个数组，他与整个数组无关

虽然```temp```和```&temp```的值是相同的，但是他们的含义却完全不同

-   ```temp```里是这个数组的第一个元素的地址，也就是说```temp```指向的是数组的第一个元素
-   ```&temp```代表的是**整个数组**的首地址，```&temp```指向的是整个数组，也就是说他是一个数组指针

