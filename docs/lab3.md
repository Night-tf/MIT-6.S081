# Lab 3 总结
本节学习了《xv6:a simple, Unix-like teaching operating system》第三章内容，查看了`kernel/proc.c`，`kernel/kalloc.c`，`kernel/vm.c`,`kernel/exec`中的部分源码

1. 通过阅读源码了解了进程创建时的页表创建过程，物理地址的分配，物理地址和虚拟地址的映射创建过程（PTE创建过程），PTE的销毁过程以及物理地址的释放过程。
2. 深刻了解了页表的翻译过程，PTE的含义，以及由虚拟地址映射到物理地址的过程。

一些思考，为什么从内核态传输数据到用户态需要使用`copyout`呢
- `copyout`的内部是算出了用户地址空间的虚拟地址对应的物理地址，然后对这个物理地址进行`memmove`操作。
- 因为在内核态下，默认的虚拟地址到物理地址的翻译是通过内核的页表来实现的，也就是直接对用户地址空间的虚拟地址进行`memmove`会使用内核页表来翻译，造成非法访问
- 所以我们需要计算出用户地址空间的虚拟地址对应的物理地址，然后直接操作该物理地址来进行读写。好像其中还借助了内核直接映射的功能。


## 3 Page tables
页表让每个进程都有自己独立的地址空间和内存，页表使得xv6能够隔离各个进程的地址空间并且将他们多路传输到一个物理内存

### 3.1 Paging hardware
物理内存是用物理地址来索引的，页表通过将每个虚拟地址映射到一个物理地址来建立起两种地址的连接。

xv6运行在Sv39 RISC-V上，它只使用64位虚拟地址的低39位，这39位中的底12位是页内偏移，高27位是页表索引。也就是说一个页的大小是4096字节（$$2^12$$），一个页表最多可以有$$2^27$$个page table entry(PTE)页表项。每个PTE含有一个44位的physical page number(PPN)以及10位的标志位，总共是54位。将虚拟地址翻译成物理地址时，物理地址的高44位就是PTE中的44位的PPN，物理地址的低12位也就是虚拟地址的低12位的页内偏移，这样我们就得到了56位的物理地址。每个PTE用8字节来储存，最上面还有10位可以用来拓展物理空间大小。而虚拟地址的高25位也可以用来拓展虚拟内存空间大小。

实际上，页表并不是作为一个包含了$$2^27$$个PTE的大列表来储存的，而是采用了三级树的形式储存在物理内存中。树的根节点是一个4096字节大小，包含512个PTE的页，每个PTE都储存了下一级页表的页物理地址，第二级一共有512个页，第三集一共有512*512个页。每个虚拟地址的39位中的高27位用来索引页表项，因此27位中的高9位用来确定一级页表中PTE的位置，中9位用来确定二级页表中PTE的位置，低9位用来确定三级页表中PTE的位置。最上级页表的物理地址记录在`satp`寄存器中，每个CPU都有自己的`satp`寄存器，因此不同的CPU可以执行不同的进程，每个`satp`中的地址都记录了一个不同的物理地址，以及这个物理地址背后的不同的虚拟地址空间

如果翻译地址需要的3个PTE中的任何一个不存在，页表就会发起page-fault exception缺页中断，进入内核态并处理这个错误。

三级页表能够让我们以一种更节约内存的方式来管理虚拟内存，
- 我们无需将所有的页表全部加载到内存中，需要哪个，再加载对应的即可。
- 对应一个虚拟地址的映射，我们可以节省511个二级页的空间，以及511*512个三级页的空间
三级页表的缺点是CPU需要至少三次访存才能完成虚拟地址到物理地址的映射，这期间会消耗很多时间。解决的方法是Translation Look-aside Buffer(TLB)，将最近使用的页表项放在TLB中（CPU缓存）

每个PTE中都有标志位告诉硬件相关的虚拟地址如何被使用。PTE_V表示该页是否合法。PTE_R,PTE_W,PTE_X表示该页能否读，写以及执行。PTE_U控制user mode的指令能否访问该也，如果PTE_U = 0,表示只有supervisor才能访问该页

指令只能使用虚拟地址，之后页表将虚拟地址翻译成物理地址，并且将其发送给DRAM来进行读或者写。

虚拟内存并不是实际存在的物体，它是内核用来管理物理内存和虚拟地址的抽象和机制的总称

### 3.2 Kernel address space
xv6位每个进程提供了一个页表来描述进程的用户地址空间，同时还提供了一个页表来描述内核地址空间（所有进程共享）。为了让内核能够使用物理内存和硬件资源，内核需要对地址空间的布局作安排，来让自己直到哪个虚拟地址对应自己需要的资源。

QEMU会模拟一个从0x80000000开始，一直到0x86400000（PHYSTOP）结束的RAM。QEMU还会模拟设备接口，并且将设备接口以memory-mapped控制寄存器的方式暴露给软件，这些寄存器位于0x80000000以下的物理地址空间。内核对这些物理地址的读写是直接和设备交互，而不是RAM（无需通过RAM）。

内核获取RAM和设备寄存器的方式是直接映射：映射资源的虚拟地址直接等于物理地址。比如内核的地址`KERNBASE=0x80000000`,不管是物理地址空间和虚拟地址空间，内核都是在这个位置。直接映射能够简化内核读写物理地址，比如`fork`为子进程分配用户空间时，分配器返回的是内存的物理地址，`fork`将父进程的用户内存拷贝给子进程时，直接将这个物理地址作为虚拟地址来使用。
有一些内核的虚拟地址不是直接映射的：
- trampoline page：在虚拟地址空间的顶部映射，user page tables也是这个虚拟地址
- kennrl stack page：每个进程都有自己的内核栈，每个内核栈的下面都有一个没有映射的guard page，这个页的PTE的PTE_V是0，guard page的作用是当内核栈溢出的时候可以保护其他内核内存不被改写。

内核可以通过high-memory mappings来使用他自己的栈，也可以通过直接映射的方法。如果采用直接映射的方法，那么guard page需要涉及虚拟内存的映射，否则会guard page会直接指向物理内存而难以使用。

### 3.3 Code:creating an address space
xv6操作地址空间和页表的代码大部分在`kernel/vm.c`中。最主要的结构体是`pagetable_t`，它是一个指向页表的指针。以`kvm`开头的函数都与kernel page table有关，以`uvm`开头的函数都与user page table有关，其他函数两者都适用。
重要的函数：
- `walk`：接收一个页表和一个虚拟地址，找到这个虚拟地址对应的最底层页表中的PET，并返回指向该PTE的指针
- `mappages`：接收一个页表，一个虚拟地址和一个物理地址，在页表中创建一个新的PTE完成虚拟地址和物理地址的映射
- `kvminit`：创建kernel的页表，使用`kvmmake`来完成直接映射
- `kvmmake`：使用`kalloc`分配一个物理页，在这个物理页上完成直接映射，直接映射使用的是`kvmmap`，`kvmmap`就是调用了`mappages`
- `proc_mapstacks`（在`kernel/proc.c`中）：为每个进程分配一个kernel stack，同是创建虚拟地址和物理地址映射，在创建映射的时候带上了guard page
- `kvminithart`：将kernel页表的物理地址写入`satp`寄存器中，之后CPU就可以用这个页表来翻译地址了
**上述代码的操作都依赖于物理内存和内核虚拟内存之间的直接映射**，比如`walk`中，当我们获得了下一级页表的物理地址之后，直接就将该物理地址作为虚拟地址来使用去寻找更下一级的PTE（而指令讲道理是只能操作虚拟地址的，这里直接就将物理地址作为虚拟地址来操作了）

每个RISC-V CPU都会在TLB中缓存PTE，当xv6改变了页表时，必须通知CPU当前TLB中的内存不合法了，要取消掉，否则可能会访问其他进程的内存造成破坏。取消当前TLB的指令是`sfence.vma`，xv6在`kvmininhart`重新加载`satp`寄存器后执行该指令来刷新TLB

### 3.4 Physical memory allocation
xv6将内核结尾和`PHYSTOP`之间的物理内存用于运行时分配，一次分配或者释放的都是整个4096字节大小的页。同时用一个链表来记录空闲的页，当分配页的时候，从这个链表中删除该页，当释放页的时候，把这个页加入到链表中

### 3.5 Code：Physical memory allocator
内存分配器在`kernel/kalloc.c`中，分配器的数据结构是一个关于能够用于分配的物理内存页的free list
。每个空闲页的列表元素都是一个`struct run`，每个`run`的数据结构储存在空闲页本身。这个空闲列表`freelist`被一个spin lock所保护，两者一起包装在`struct kmem`中
- `kinit`：通过初始化spin lock以及调用`freerange`来初始化分配器，通过`freerange`将Kernel结尾到`PHYSTOP`之间的所有空闲物理页都加入到`kmem`的`freelist`中
- `freerange`：调用`kfree`对范围内的所有页释放物理内存并添加到`freelist`中
- `kfree`：通过将一个页的所有位置为1来释放内存，并将这个释放后的页加入到`freelist`。
一个PTE只能指向对齐在4096字节处的物理地址（也就是必须是4096的整数倍），`freerange`使用`PGROUNDUP`来保证只释放对齐的物理地址

非配器代码中有很多C语言类型转换，有两个原因：
- 一是有时候我们需要将地址作为整数来进行代数运算，另一些时候我们需要将地址视为指针来读写内存
- 二是分配和释放内存的时候改变了内存的种类

### 3.6 Process address space
每个进程都有自己单独的页表来维护自己的虚拟地址空间，当xv6在不同进程间切换时，页表也随之改变。进程的用户内存从虚拟地址0开始一直到`MAXVA`。
当进程向xv6索要更多空间时，xv6首先使用`kalloc`来分配物理页，然后在进程的页表中增加PTE指向这个新的物理页，并且设置页面的标志位。对于没有使用的PTE,PTE_V是空的(0)

页表的使用有三个优点：
- 每个进程的页表会将虚拟地址映射到不同的物理地址，这使得各个进程都有自己的用户内存
- 每个进程都拥有从0开始的连续的虚拟地址，但是进程的物理地址是可以不连续的
- 内核在用户地址空间顶部映射trampoline，因此这个页的物理地址能够在所有地址空间中可见

下图是一个进程刚刚被`exec`调用后的用户地址空间的分布其中的stack只有一页，其中包含了`exec`调用的命令的参数，这些参数使得`main`可以执行。stack下方是一个无法访问的guard page，它的PTE_U是0，这个页用来检测stack溢出，一旦溢出就会产生page-fault exception。这时实际的操作系统可能会分配更多的内存

### 3.7 Code：sbrk
`sbrk`是一个用来增加或者减小进程内存的系统调用。该系统调用是通过`growproc`（`kernel/proc.c`中）函数来实现的。
- `growproc`：如果传入的参数大于0，调用`uvmalloc`分配物理内存并创建PTE进行映射；如果传入的参数小于0，调用'uvmdealloc`删除PTE取消映射，并且释放物理内存
- `uvmalloc`：调用`kalloc`和`mappages`分配物理内存并创建PTE进行映射
- `uvmdealloc`：调用`walk`找到对应的PTE，删除该PTE来取消映射，并根据参数决定是否调用`kfree`释放相应的物理内存
页表不仅仅告诉硬件如何映射虚拟地址，同时也是分配给进程的物理页的唯一记录。因此我们需要在释放物理内存之前检查用户的页表。

### 3.8 Code：exec
`exec`系统调用用ELF文件中的内容初始化进程的用户地址空间部分

第一步是快速检查该文件是否含有一个ELF二进制文件，一个ELF二进制文件以`ELF_MAGIC`开头，如果ELF头部含有正确的magic number，那么`exec`认为这个二进制文件是组织完好的。
接着，`exec`使用`proc_pagetable`分配一个新的没有映射的页表，然后用`uvmalloc`为每个ELF segment分配物理空间并在页表中建立映射，接着用`loadseg`把ELF segment加载到物理空间中。`loadseg`使用`walkaddr`来找到虚拟地址映射的物理地址（是虚拟地址对应的物理页的页首地址），`walkaddr`是通过`walk`来实现的。
程序段首program section header的`filesz`可能比`memsz`要小，这些间隔用0来填充。比如`/init`文件中，`filesz`是2112比特，`memsz`是2136比特，因此`uvmalloc`会分配2136比特的物理空间，但是只从`/init`文间中读2112比特
接着`exec`分配并初始化用户栈，它仅仅只分配一页给栈。`exec`使用`copyout`将字符串变量赋值到用户栈的顶部，并且在用户栈中记录指向他们的指针，这些字符串变量就是传递给`main`的`agv`参数，`exec`还在这些指针后面放一个空指针。用户栈中的前三项就是fake return program counter，`argc`和`argv`指针。用户栈下面的一个页是保护页
- 保护页能够防止栈溢出
- 在参数过大的时候也能起到保护作用，因为`copyout`会返回-1
`exec`在准备新内存的时候，如果发生错误的话，就跳到`bad`并且释放新的页表并返回-1。`exec`必须确定系统调用成功了才会释放进程旧的页表，否则system call失败的话，就没办法向旧页表返回-1。

### 3.9 Real world
xv6将kernel加载到0x80000000这一RAM物理地址中，但是实际上很多机器的RAM地址并不是这个，而是随机的
实际的机器并不一定使用4kb大小的页，可能在需要更大内存的地方使用更大的页，这样能够减小操作页表的开销。
现在的人更加关注速度而不是空间效率，因此一个好的内核应该能够支持各种大小的内存分配。


## Lab 3:page tables
### 1. Speed up system calls
分配一个物理页，然后建立虚拟地址和物理地址的映射，最后记得释放分配的页以及取消页表映射。
需要在`kernel/proc.c`中的`allocproc`中对这个页中的结构体进行初始化
- 这里为什么不能在`kernel/proc.c`中的`proc_pagetable`中重新定义一个结构体，然后使用`memmove`来赋值？？？

### 2. Print a page table
打印页表，这里的打印页表指的是递归打印一个进程的所有页表。编写一个递归打印函数即可，递归的思路可以参考`freewalk`。使用`%p`来打印地址（指针）。
这里需要使用PTE项和物理地址之间的转换，一个PTE是54位，高44位是物理地址的高44位。物理地址是56位，剩下的12位是偏移量。$$2^12 = 4096$$，正好是一个页的大小，所以从PTE获取的物理地址的低12位都是0，指向的是一个页表的起始地址，加上12位的偏移量来代表整个页的地址。

### 3. Detecting which pages have been accessed
通过PTE中的标志位PTE_A来判断某个页是否被访问。
刚开始我们拿到的是需要判断的第一个页的虚拟地址以及需要判断的后续页数。因此我们需要使用`walk`来找到页表中虚拟地址对应的PTE，然后判断其中的PTE_A位，并且之后将该位复位（置0）。
